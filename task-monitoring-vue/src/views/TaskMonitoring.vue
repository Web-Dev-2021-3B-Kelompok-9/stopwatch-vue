<template>
    <main class="home">
        <div>
            <div id="task-list" class="task-list">
                <!--
                    task list container
                    new task will autogenerated here
                -->
                <task-container
                v-for="task in this.taskListData"
                :key="task.id"
                :taskData="task"
                @ondataupdated="updateDataList"
                @stopTime="preventMultiStopwatch"
                />
                <!-- add task button -->
                <add-task
                @openAddTaskModul="openAddTaskModul()"/>
                <!-- add task button -->
            </div>
            <add-task-modal
            @closeAddTaskModul="closeAddTaskModul()"
            @addTask="addTask"/>
        </div>
    </main>
</template>
<script>
import AddTask from '../components/AddTask.vue';
import AddTaskModal from '../components/AddTaskModal.vue';
import TaskContainer from '../components/Task.vue';
import Stopwatch from '../object/stopwatch.js';
import TaskMonitoringDataService from '../services/task-momitoring-data-service.js';

export default ({
  components: {
    AddTask,
    AddTaskModal,
    TaskContainer,
  },
  created() {
    this.updateDataList();
  },
  data() {
    return {
      taskListData: [],
      isModulOpen: false,
    };
  },
  methods: {

    async getAllTask() {
      let temp = await TaskMonitoringDataService.staticgetAll();
      temp = temp.data;
      const temptaskListData = [];
      temp.forEach((element) => {
        temptaskListData.unshift(this.dataBaseGetTask(element));
      });
      this.taskListData = temptaskListData;
      // eslint-disable-next-line no-console
      console.log(this.taskListData);
    },
    dataBaseGetTask(taskData) {
      // eslint-disable-next-line no-console
      // console.log(taskData);
      const element = taskData;

      const tempStopwatch = new Stopwatch(element.id);
      tempStopwatch.updateTime(
        element.stopwatch_time_hh,
        element.stopwatch_time_mm,
        element.stopwatch_time_ss);
      tempStopwatch.updateTimeEnd(
        element.time_end_hh,
        element.time_end_mm,
        element.time_end_ss);
      tempStopwatch.timerOn = element.timer_on;
      tempStopwatch.isEnd = element.is_end;
      tempStopwatch.timeCycle = element.time_cycle;

      const tempDate = new Date(element.deadline);

      return {
        id: element.id,
        title: element.tittle,
        isTaskNotCompleted: element.is_task_not_completed,
        isTimePaused: element.is_time_paused,
        deadline: tempDate,
        Stopwatch: tempStopwatch,
      };
    },
    openAddTaskModul() {
      document.querySelector('#add-task-modal').style.display = 'block';
    },
    closeAddTaskModul() {
      document.querySelector('#add-task-modal').style.display = 'none';
    },
    addTask() {
      document.querySelector('#add-task-modal').style.display = 'none';
      this.updateDataList();
    },
    findTaskIndex(taskID) {
    // find task index in the array use task ID
    // return index (number)
      let index = -1;
      // eslint-disable-next-line no-plusplus
      for (let i = 0; i < this.taskListData.length; i++) {
        if (this.taskListData[i].id === taskID) {
          index = i;
        }
      }
      return index;
    },
    GetTaskByID(taskID) {
    // find task in the array use task ID
    // return object of task
      const index = this.findTaskIndex(taskID);
      const task = this.taskListData[index];
      return task;
    },
    updateDataList() {
      setTimeout(() => { this.getAllTask(); }, 100);
      this.$forceUpdate();
    },
    parseToDatabaseTaskObject(Task) {
    // parsed task object,
    // postgres cant save an object data type in one cell
    // so we need to extract stopwatch and time
      return {
        id: Task.id,
        stopwatch_time_hh: Task.Stopwatch.Time.hh,
        stopwatch_time_mm: Task.Stopwatch.Time.mm,
        stopwatch_time_ss: Task.Stopwatch.Time.ss,
        title: Task.title,
        is_task_not_completed: Task.isTaskNotCompleted,
        is_time_paused: Task.isTimePaused,
        deadline: Task.deadline,
        timer_on: Task.Stopwatch.timerOn,
        is_end: Task.Stopwatch.isEnd,
        time_end_hh: Task.Stopwatch.timeEnd.hh,
        time_end_mm: Task.Stopwatch.timeEnd.mm,
        time_end_ss: Task.Stopwatch.timeEnd.ss,
        time_cycle: Task.Stopwatch.timeCycle,
        text_id: Task.Stopwatch.textId,
      };
    },
    dataBaseUpdateDataTask(task) {
    // update specified task to database
      const updatedTask = this.parseToDatabaseTaskObject(task);
      TaskMonitoringDataService.update(updatedTask);
    },
    preventMultiStopwatch() {
      // stop running stopwatch , make itu pause
      const runningStopwatchID = localStorage.getItem('runningStopwatchID');
      const task = this.GetTaskByID(runningStopwatchID);
      const index = this.findTaskIndex(runningStopwatchID);
      this.taskListData[index].Stopwatch.playaButtonEvent('pause');
      const uniqStartButton = document.getElementById(`start-button${task.id}`);
      uniqStartButton.setAttribute('class', 'pause');
      uniqStartButton.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play-circle" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="svg-inline--fa fa-play-circle fa-w-16 fa-3x"><path fill="currentColor" d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm115.7 272l-176 101c-15.8 8.8-35.7-2.5-35.7-21V152c0-18.4 19.8-29.8 35.7-21l176 107c16.4 9.2 16.4 32.9 0 42z" class=""></path></svg>';
      this.dataBaseUpdateDataTask(task);
    },

  },
  setup() {

  },
});
</script>

